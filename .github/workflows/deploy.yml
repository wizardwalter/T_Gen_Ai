name: Deploy

on:
  # push:
  #   branches: [main] Not needed yet
  workflow_dispatch:
    
permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-east-1
      TF_VAR_acm_certificate_arn: ${{ secrets.TF_VAR_acm_certificate_arn }}
      TF_VAR_cloudfront_domain_names: ${{ secrets.CLOUDFRONT_DOMAIN_NAMES }}
      TF_VAR_canonical_hostname: ${{ secrets.TF_VAR_CANONICAL_HOSTNAME }}
      TF_VAR_nextauth_url: ${{ secrets.NEXTAUTH_URL }}
      TF_VAR_next_public_api_base: ${{ secrets.NEXT_PUBLIC_API_BASE }}
      TF_VAR_google_client_id: ${{ secrets.GOOGLE_CLIENT_ID }}
      TF_VAR_google_client_secret: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      TF_VAR_nextauth_secret: ${{ secrets.NEXTAUTH_SECRET }}
      NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
      NEXT_PUBLIC_API_BASE: ${{ secrets.NEXT_PUBLIC_API_BASE }}
      NEXT_PUBLIC_ICON_BASE: ${{ secrets.NEXT_PUBLIC_ICON_BASE }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: gha-deploy

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: >
          terraform init
          -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}"
          -backend-config="key=${{ secrets.TF_STATE_KEY }}"
          -backend-config="region=${{ env.AWS_REGION }}"
          -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Compute API repo
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "API_REPO=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-api" >> $GITHUB_ENV
          echo "TF_VAR_api_image=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-api:latest" >> $GITHUB_ENV
          echo "UI_REPO=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-ui" >> $GITHUB_ENV
          echo "TF_VAR_ui_image=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-ui:latest" >> $GITHUB_ENV

      - name: Terraform apply (create ECR first)
        working-directory: terraform
        run: terraform apply -auto-approve -target=aws_ecr_repository.api -target=aws_ecr_repository.ui

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $API_REPO
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $UI_REPO

      - name: Build and push API image
        run: |
          docker build -t $API_REPO:latest api
          docker push $API_REPO:latest

      - name: Build and push UI image
        run: |
          docker build \
            --build-arg NEXT_PUBLIC_API_BASE=${NEXT_PUBLIC_API_BASE} \
            --build-arg NEXTAUTH_URL=${NEXTAUTH_URL} \
            --build-arg NEXT_PUBLIC_ICON_BASE=${NEXT_PUBLIC_ICON_BASE} \
            -t $UI_REPO:latest ui
          docker push $UI_REPO:latest

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve

      - name: Fetch outputs for UI deploy
        working-directory: terraform
        run: |
          echo "CF_DIST_ID=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_ENV
          echo "APP_HOST_INSTANCE_ID=$(terraform output -raw app_host_instance_id)" >> $GITHUB_ENV

      - name: Wait for app host ready
        run: |
          set -e
          INSTANCE_ID="${APP_HOST_INSTANCE_ID}"
          REGION="${AWS_REGION}"
          echo "Waiting for instance $INSTANCE_ID to pass status checks..."
          aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID" --region "$REGION"
          echo "Waiting for SSM ping..."
          for i in {1..30}; do
            PING=$(aws ssm describe-instance-information \
              --filters Key=InstanceIds,Values="$INSTANCE_ID" \
              --region "$REGION" \
              --query 'InstanceInformationList[0].PingStatus' --output text || true)
            if [ "$PING" = "Online" ]; then
              echo "SSM Online"
              exit 0
            fi
            sleep 10
          done
          echo "SSM not online after wait"
          exit 1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Restart app host via SSM
        run: |
          set -e
          INSTANCE_ID="${APP_HOST_INSTANCE_ID}"
          REGION="${AWS_REGION}"
          UI_IMAGE="${UI_REPO}:latest"
          API_IMAGE="${API_REPO}:latest"

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"set -e\",
              \"REGION=$REGION\",
              \"ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text)\",
              \"UI_IMAGE=$UI_IMAGE\",
              \"API_IMAGE=$API_IMAGE\",
              \"if ! command -v docker >/dev/null 2>&1; then yum update -y && (amazon-linux-extras install docker -y || yum install -y docker); systemctl enable docker; systemctl start docker; fi\",
              \"aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin \${ACCOUNT_ID}.dkr.ecr.\${REGION}.amazonaws.com\",
              \"docker pull $UI_IMAGE || true\",
              \"docker pull $API_IMAGE || true\",
              \"docker stop ui || true && docker rm ui || true\",
              \"docker stop api || true && docker rm api || true\",
              \"docker run -d --name ui -p 3000:3000 -e NEXTAUTH_URL=${NEXTAUTH_URL} -e NEXT_PUBLIC_API_BASE=${NEXT_PUBLIC_API_BASE} -e NEXT_PUBLIC_ICON_BASE=${NEXT_PUBLIC_ICON_BASE} -e GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID} -e GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET} -e NEXTAUTH_SECRET=${NEXTAUTH_SECRET} $UI_IMAGE\",
              \"docker run -d --name api -p 4000:4000 $API_IMAGE\",
              \"docker ps\"
            ]" \
            --region "$REGION" \
            --query 'Command.CommandId' \
            --output text)

          echo "SSM restart command: $CMD_ID"

          # Allow more time and emit stdout/stderr on failure
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region "$REGION" \
              --query 'Status' \
              --output text || true)
            if [ "$STATUS" = "Success" ]; then
              echo "SSM restart succeeded"
              exit 0
            fi
            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "SSM restart failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --region "$REGION" \
                --query '{status:Status,stdOut:StandardOutputContent,stdErr:StandardErrorContent}'
              exit 1
            fi
            sleep 10
          done

          echo "SSM restart timed out"
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region "$REGION" \
            --query '{status:Status,stdOut:StandardOutputContent,stdErr:StandardErrorContent}'
          exit 1

          
