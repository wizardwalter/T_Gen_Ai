name: Deploy App

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy-app:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-east-1
      TF_VAR_acm_certificate_arn: ${{ secrets.TF_VAR_acm_certificate_arn }}
      TF_VAR_cloudfront_domain_names: ${{ secrets.CLOUDFRONT_DOMAIN_NAMES }}
      TF_VAR_nextauth_url: ${{ secrets.NEXTAUTH_URL }}
      TF_VAR_next_public_api_base: ${{ secrets.NEXT_PUBLIC_API_BASE }}
      TF_VAR_google_client_id: ${{ secrets.GOOGLE_CLIENT_ID }}
      TF_VAR_google_client_secret: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      TF_VAR_nextauth_secret: ${{ secrets.NEXTAUTH_SECRET }}
      NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
      NEXT_PUBLIC_API_BASE: ${{ secrets.NEXT_PUBLIC_API_BASE }}
      GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: gha-app-deploy

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0
          terraform_wrapper: false

      - name: Terraform Init (outputs only)
        working-directory: terraform
        run: >
          terraform init
          -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}"
          -backend-config="key=${{ secrets.TF_STATE_KEY }}"
          -backend-config="region=${{ env.AWS_REGION }}"
          -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"

      - name: Compute repos
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "API_REPO=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-api" >> $GITHUB_ENV
          echo "TF_VAR_api_image=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-api:latest" >> $GITHUB_ENV
          echo "UI_REPO=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-ui" >> $GITHUB_ENV
          echo "TF_VAR_ui_image=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/aidevops-ui:latest" >> $GITHUB_ENV

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $API_REPO
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $UI_REPO

      - name: Build and push API image
        run: |
          docker build -t $API_REPO:latest api
          docker push $API_REPO:latest

      - name: Build and push UI image
        run: |
          docker build -t $UI_REPO:latest ui
          docker push $UI_REPO:latest

      - name: Fetch outputs (host and CF)
        working-directory: terraform
        run: |
          echo "APP_HOST_INSTANCE_ID=$(terraform output -raw app_host_instance_id)" >> $GITHUB_ENV
          echo "CF_DIST_ID=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_ENV

      - name: Reboot app host
        run: |
          aws ec2 reboot-instances --instance-ids "$APP_HOST_INSTANCE_ID" --region $AWS_REGION
          echo "Waiting for instance $APP_HOST_INSTANCE_ID to pass status checks..."
          aws ec2 wait instance-status-ok --instance-ids "$APP_HOST_INSTANCE_ID" --region $AWS_REGION
          echo "Waiting for SSM ping..."
          for i in {1..30}; do
            PING=$(aws ssm describe-instance-information \
              --filters Key=InstanceIds,Values="$APP_HOST_INSTANCE_ID" \
              --region "$AWS_REGION" \
              --query 'InstanceInformationList[0].PingStatus' --output text || true)
            if [ "$PING" = "Online" ]; then
              echo "SSM Online"
              exit 0
            fi
            sleep 10
          done
          echo "SSM not online after wait"
          exit 1

      - name: Verify containers
        run: |
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$APP_HOST_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands='["docker ps"]' \
            --region "$AWS_REGION" \
            --query 'Command.CommandId' --output text)
          sleep 5
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$APP_HOST_INSTANCE_ID" \
            --region "$AWS_REGION" \
            --query '{status:Status,stdOut:StandardOutputContent,stdErr:StandardErrorContent}'

      - name: Invalidate CloudFront
        if: env.CF_DIST_ID != ''
        run: |
          aws cloudfront create-invalidation --distribution-id "$CF_DIST_ID" --paths "/*" --region $AWS_REGION
